<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>METAR Availability Timeline</title>
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #0f172a;
      --muted: #334155;
      --ok: #15803d;
      --empty: #a16207;
      --error: #b91c1c;
      --missing: #94a3b8;
      --accent: #0369a1;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at top left, #e0f2fe 0%, var(--bg) 45%);
      min-height: 100vh;
    }
    a { color: #075985; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; }
    .panel {
      background: var(--card);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 25px rgba(2, 6, 23, 0.08);
      margin-bottom: 10px;
    }
    h1 { margin-top: 0; font-size: 1.4rem; }
    h2 { margin: 0 0 6px 0; font-size: 1.05rem; }
    p { color: var(--muted); }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px; }
    input, button {
      padding: 7px 9px;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      font-size: 0.85rem;
    }
    button { background: var(--accent); border: none; color: #fff; cursor: pointer; }
    .legend { display: flex; gap: 10px; color: var(--muted); font-size: 0.78rem; flex-wrap: wrap; }
    .dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; }
    .small { font-size: 0.76rem; color: var(--muted); margin: 4px 0; }
    .grid-wrap { overflow-x: auto; border: 1px solid #e2e8f0; border-radius: 8px; padding: 8px; }
    .axis-row {
      display: grid;
      gap: 2px;
      margin-left: 230px;
      margin-bottom: 6px;
    }
    .axis-tick {
      font-size: 0.62rem;
      color: #64748b;
      text-align: center;
      white-space: nowrap;
      width: 12px;
      overflow: visible;
    }
    .heatmap-row {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      gap: 8px;
    }
    .heatmap-label {
      width: 220px;
      flex: 0 0 220px;
      font-size: 0.78rem;
    }
    .heatmap-grid {
      display: grid;
      grid-auto-flow: column;
      gap: 2px;
    }
    .cell {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      display: inline-block;
      cursor: default;
    }
    .ok { background: var(--ok); }
    .empty { background: var(--empty); }
    .error { background: var(--error); }
    .missing { background: var(--missing); }
    .station-block { margin-bottom: 10px; }
    .metrics { font-size: 0.64rem; color: #475569; margin-top: 3px; line-height: 1.2; }
    .hidden { display: none; }
    .metar-item {
      display: block;
      padding: 6px 8px;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 0.78rem;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>METAR Availability Timeline</h1>
      <p>Hourly checkpoints stacked by monitored station. <a href="admin.html">Admin</a></p>

      <div class="controls">
        <input id="limit" type="number" min="24" max="240" value="72" />
        <button id="refresh">Refresh</button>
      </div>

      <div class="legend">
        <span><i class="dot" style="background: var(--ok)"></i>Run OK</span>
        <span><i class="dot" style="background: var(--empty)"></i>Run Empty</span>
        <span><i class="dot" style="background: var(--error)"></i>Run Error</span>
        <span><i class="dot" style="background: var(--ok)"></i>Station OK at checkpoint</span>
        <span><i class="dot" style="background: var(--empty)"></i>Station Empty at checkpoint</span>
      </div>
      <p class="small" id="status"></p>
    </div>

    <div class="panel">
      <h2>Station Heatmaps</h2>
      <p class="small">Each tracked station has its own timeline heatmap. Hover a cell for UTC date/time and status.</p>
      <div class="grid-wrap">
        <div id="heatmap"></div>
      </div>
    </div>

    <div class="panel">
      <h2>All Recent METAR Links</h2>
      <button id="toggleMetars" type="button">Show</button>
      <div id="allMetars" class="hidden"></div>
    </div>
  </div>

  <script>
    const API = "__API_URL__";
    const DEFAULT_STATION = "__DEFAULT_STATION__";

    function el(id) { return document.getElementById(id); }
    let metarsExpanded = false;

    function fmtDate(iso) {
      const d = new Date(iso);
      const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
      const dd = String(d.getUTCDate()).padStart(2, "0");
      return `${mm}/${dd}`;
    }

    function fmtTime(iso) {
      const d = new Date(iso);
      const hh = String(d.getUTCHours()).padStart(2, "0");
      return `${hh}:00Z`;
    }
    function fmtDateTime(iso) {
      const d = new Date(iso);
      const yyyy = d.getUTCFullYear();
      const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
      const dd = String(d.getUTCDate()).padStart(2, "0");
      const hh = String(d.getUTCHours()).padStart(2, "0");
      const mi = String(d.getUTCMinutes()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}Z`;
    }

    function hourKey(iso) {
      const d = new Date(iso);
      d.setUTCMinutes(0, 0, 0);
      return d.toISOString();
    }

    function metarLink(station) {
      return `https://aviationweather.gov/data/metar/?id=${encodeURIComponent(station)}&hours=3`;
    }

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    }

    function buildMetarHourSet(items) {
      const set = new Set();
      (items || []).forEach(m => {
        if (m.observation_time) set.add(hourKey(m.observation_time));
      });
      return set;
    }

    function stationStatusForCheckpoint(run, hasMetar) {
      if (run.status === "error") return "error";
      if (run.status === "empty") return "empty";
      return hasMetar ? "ok" : "empty";
    }

    function stationMetrics(runs, stationHourSet) {
      let ok = 0, empty = 0, error = 0;
      runs.forEach(run => {
        const hasMetar = stationHourSet.has(hourKey(run.checked_at_utc));
        const status = stationStatusForCheckpoint(run, hasMetar);
        if (status === "ok") ok += 1;
        else if (status === "error") error += 1;
        else empty += 1;
      });
      const total = runs.length;
      const availability = total ? ((ok / total) * 100).toFixed(1) : "0.0";
      return { total, ok, empty, error, availability };
    }

    function renderHeatmap(runs, stations, stationMetars) {
      const box = el("heatmap");
      const checkpoints = runs.map(r => r.checked_at_utc);
      if (!checkpoints.length) {
        box.innerHTML = `<p class="small">No checkpoints available yet.</p>`;
        return;
      }
      let html = `<div class="axis-row" style="grid-template-columns: repeat(${checkpoints.length}, 12px)">`;
      checkpoints.forEach((cp, idx) => {
        const curr = fmtDate(cp);
        const prev = idx > 0 ? fmtDate(checkpoints[idx - 1]) : "";
        html += `<div class="axis-tick" title="${fmtDateTime(cp)}">${curr !== prev ? curr : ""}</div>`;
      });
      html += `</div>`;
      html += `<div class="heatmap-row"><div class="heatmap-label"><strong>Collector Run</strong></div><div class="heatmap-grid" style="grid-template-columns: repeat(${checkpoints.length}, 12px)">`;
      runs.forEach(run => {
        const cls = run.status === "ok" ? "ok" : run.status === "error" ? "error" : "empty";
        html += `<span class="cell ${cls}" title="Collector | ${fmtDateTime(run.checked_at_utc)} | ${run.status.toUpperCase()}"></span>`;
      });
      html += `</div></div>`;

      stations.forEach(station => {
        const sid = station.station_id;
        const hours = buildMetarHourSet(stationMetars[sid] || []);
        const m = stationMetrics(runs, hours);
        html += `<div class="heatmap-row"><div class="heatmap-label"><strong>${sid}</strong><div class="metrics">CP ${m.total} | OK ${m.ok} | Empty ${m.empty} | Error ${m.error} | Avail ${m.availability}%</div></div><div class="heatmap-grid" style="grid-template-columns: repeat(${checkpoints.length}, 12px)">`;
        checkpoints.forEach(cp => {
          const run = runs.find(r => r.checked_at_utc === cp);
          const present = hours.has(hourKey(cp));
          const cls = stationStatusForCheckpoint(run, present);
          html += `<span class="cell ${cls}" title="${sid} | ${fmtDateTime(cp)} | ${cls.toUpperCase()}"></span>`;
        });
        html += `</div></div>`;
      });
      box.innerHTML = html;
    }

    function renderAllMetars(stations, stationMetars) {
      const box = el("allMetars");
      box.innerHTML = "";

      stations.forEach(station => {
        const sid = station.station_id;
        const items = (stationMetars[sid] || []).slice(-12).reverse();
        const section = document.createElement("div");
        section.className = "station-block";
        section.innerHTML = `<h3>${sid}</h3>`;

        items.forEach(m => {
          const a = document.createElement("a");
          a.className = "metar-item";
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.href = metarLink(sid);
          a.textContent = `${m.observation_time || ""} | ${m.flight_category || "N/A"} | ${m.raw_text || ""}`;
          section.appendChild(a);
        });

        if (!items.length) {
          const p = document.createElement("p");
          p.className = "small";
          p.textContent = "No recent METAR rows found.";
          section.appendChild(p);
        }

        box.appendChild(section);
      });
    }

    async function load() {
      const limit = Math.max(24, Math.min(Number(el("limit").value || 72), 240));
      el("status").textContent = "Loading...";

      try {
        const [runsRes, stationsRes] = await Promise.all([
          fetchJson(`${API}?type=runs&limit=${limit}`),
          fetchJson(`${API}?type=stations`)
        ]);

        const runs = runsRes.items || [];
        const stations = (stationsRes.items || []).filter(x => x.enabled !== false);
        if (!stations.length) stations.push({ station_id: DEFAULT_STATION, enabled: true });

        const metarResults = await Promise.all(
          stations.map(s => fetchJson(`${API}?type=metars&station=${encodeURIComponent(s.station_id)}&limit=${limit * 2}`))
        );
        const stationMetars = {};
        stations.forEach((s, idx) => { stationMetars[s.station_id] = metarResults[idx].items || []; });

        renderHeatmap(runs, stations, stationMetars);
        renderAllMetars(stations, stationMetars);
        el("status").textContent = `Loaded ${runs.length} checkpoints and ${stations.length} stations.`;
      } catch (err) {
        el("status").textContent = `Failed to load data: ${err.message}`;
      }
    }

    el("toggleMetars").addEventListener("click", () => {
      metarsExpanded = !metarsExpanded;
      el("allMetars").classList.toggle("hidden", !metarsExpanded);
      el("toggleMetars").textContent = metarsExpanded ? "Hide" : "Show";
    });

    el("refresh").addEventListener("click", load);
    load();
  </script>
</body>
</html>
